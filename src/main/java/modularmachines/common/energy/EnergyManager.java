package modularmachines.common.energy;

import javax.annotation.Nullable;

import net.minecraft.nbt.NBTTagCompound;

import net.minecraftforge.common.capabilities.Capability;
import net.minecraftforge.energy.CapabilityEnergy;
import net.minecraftforge.energy.EnergyStorage;
import net.minecraftforge.energy.IEnergyStorage;

import modularmachines.common.energy.tesla.TeslaConsumerWrapper;
import modularmachines.common.energy.tesla.TeslaHelper;
import modularmachines.common.energy.tesla.TeslaHolderWrapper;
import modularmachines.common.energy.tesla.TeslaProducerWrapper;

import net.darkhax.tesla.api.ITeslaConsumer;
import net.darkhax.tesla.api.ITeslaHolder;
import net.darkhax.tesla.api.ITeslaProducer;

public class EnergyManager extends EnergyStorage {
	private EnergyTransferMode externalMode = EnergyTransferMode.BOTH;
	
	public EnergyManager(int maxTransfer, int capacity) {
		super(capacity, maxTransfer, maxTransfer);
	}
	
	public void setExternalMode(EnergyTransferMode externalMode) {
		this.externalMode = externalMode;
	}
	
	public EnergyTransferMode getExternalMode() {
		return externalMode;
	}
	
	public void readFromNBT(NBTTagCompound nbt) {
		final int energy = nbt.getInteger("Energy");
		
		setEnergyStored(energy);
	}
	
	public NBTTagCompound writeToNBT(NBTTagCompound nbt) {
		nbt.setInteger("Energy", energy);
		return nbt;
	}
	
	public int getMaxEnergyReceived() {
		return this.maxReceive;
	}
	
	/**
	 * Drains an amount of energy, due to decay from lack of work or other factors
	 */
	public void drainEnergy(int amount) {
		setEnergyStored(energy - amount);
	}
	
	/**
	 * Creates an amount of energy, generated by engines
	 */
	public void generateEnergy(int amount) {
		setEnergyStored(energy + amount);
	}
	
	public void setEnergyStored(int energyStored) {
		this.energy = energyStored;
		if (this.energy > capacity) {
			this.energy = capacity;
		} else if (this.energy < 0) {
			this.energy = 0;
		}
	}
	
	public boolean hasCapability(Capability<?> capability) {
		return capability == CapabilityEnergy.ENERGY ||
				capability == TeslaHelper.TESLA_PRODUCER && externalMode.canExtract() ||
				capability == TeslaHelper.TESLA_CONSUMER && externalMode.canReceive() ||
				capability == TeslaHelper.TESLA_HOLDER;
	}
	
	@Nullable
	public <T> T getCapability(Capability<T> capability) {
		if (capability == CapabilityEnergy.ENERGY) {
			IEnergyStorage energyStorage = new EnergyStorageWrapper(this, externalMode);
			return CapabilityEnergy.ENERGY.cast(energyStorage);
		} else {
			Capability<ITeslaProducer> teslaProducer = TeslaHelper.TESLA_PRODUCER;
			Capability<ITeslaConsumer> teslaConsumer = TeslaHelper.TESLA_CONSUMER;
			Capability<ITeslaHolder> teslaHolder = TeslaHelper.TESLA_HOLDER;
			
			if (capability == teslaProducer && externalMode.canExtract()) {
				return teslaProducer.cast(new TeslaProducerWrapper(this));
			} else if (capability == teslaConsumer && externalMode.canReceive()) {
				return teslaConsumer.cast(new TeslaConsumerWrapper(this));
			} else if (capability == teslaHolder) {
				return teslaHolder.cast(new TeslaHolderWrapper(this));
			} else {
				return null;
			}
		}
	}
	
}